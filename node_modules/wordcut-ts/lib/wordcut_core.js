"use strict";
const dict_1 = require("./dict");
const path_info_builder_1 = require("./path_info_builder");
const path_selector_1 = require("./path_selector");
const acceptors_1 = require("./acceptors");
const latin_rules_1 = require("./latin_rules");
const thai_rules_1 = require("./thai_rules");
var _ = require("underscore");
class WordcutCore {
    constructor() {
        this.pathSelector = new path_selector_1.PathSelector();
        this.acceptors = new acceptors_1.Acceptors();
        this.pathInfoBuilder = new path_info_builder_1.PathInfoBuilder();
        thai_rules_1.getThaiRules().forEach(x => {
            this.acceptors.creators.push(x);
        });
        latin_rules_1.getLatinRules().forEach(x => {
            this.acceptors.creators.push(x);
        });
    }
    initNoDict() {
        this.init(null, false, []);
    }
    ;
    init(dict_path, withDefault, additionalWords) {
        var dict = new dict_1.WordcutDict();
        dict.init(dict_path, withDefault, additionalWords);
        this.acceptors.creators.push(dict);
    }
    buildPath(text) {
        var self = this, path = self.pathSelector.createPath(), leftBoundary = 0;
        self.acceptors.reset();
        for (var i = 0; i < text.length; i++) {
            var ch = text[i];
            self.acceptors.transit(ch);
            var possiblePathInfos = self.pathInfoBuilder.build(path, self.acceptors.getFinalAcceptors(), i, leftBoundary, text);
            var selectedPath = self.pathSelector.selectPath(possiblePathInfos);
            path.push(selectedPath);
            if (selectedPath.type !== "UNK") {
                leftBoundary = i;
            }
        }
        return path;
    }
    pathToRanges(path) {
        var e = path.length - 1, ranges = [];
        while (e > 0) {
            var info = path[e], s = info.p;
            if (info.merge !== undefined && ranges.length > 0) {
                var r = ranges[ranges.length - 1];
                r.s = info.merge;
                s = r.s;
            }
            else {
                ranges.push({ s: s, e: e });
            }
            e = s;
        }
        return ranges.reverse();
    }
    rangesToText(text, ranges, delimiter) {
        return ranges.map(function (r) {
            return text.substring(r.s, r.e);
        }).join(delimiter);
    }
    cut(text, delimiter) {
        let path = this.buildPath(text);
        let ranges = this.pathToRanges(path);
        let del = (delimiter === undefined ? "|" : delimiter);
        let result = this.rangesToText(text, ranges, del);
        return result;
    }
    cutIntoRanges(text, noText) {
        var path = this.buildPath(text);
        var ranges = this.pathToRanges(path);
        if (!noText) {
            ranges.forEach(function (r) {
                r.text = text.substring(r.s, r.e);
            });
        }
        return ranges;
    }
    cutIntoArray(text) {
        var path = this.buildPath(text);
        var ranges = this.pathToRanges(path);
        return ranges.map(function (r) {
            return text.substring(r.s, r.e);
        });
    }
}
exports.WordcutCore = WordcutCore;
//# sourceMappingURL=wordcut_core.js.map